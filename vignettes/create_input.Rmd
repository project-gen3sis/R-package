---
title: "Creating input in gen3sis"
date: "`r format(Sys.time(),  '%d.%m.%Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating input objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  tidy=T,
  fig.align='center',
  tidy.opts = list(width.cutoff=80),
  results='hold'
)
```

This vignette aims at showing how to use the function create_input(). The function create_input() creates input objects necessary to run gen3sis: 

1) a rds file containing a landscape list of raster stacks for environmental variables; 

2) a series os rds files, one for each timestep, including distance matrices between grid cells. 


To create these files, the function requires as arguments: 

A) a named list of rasters, with each raster containing the spatio-temporal distribution of an environmental variable; 

B) a cost function defining how dispersal between particular types of cells is penalized (to be used for the calculation of the distance matrices). 

Further arguments can be modified from the default values depending on user preferences. Below, we go step by step to generate the R objects required by the function create_input(). For this exercise, we will use the simple island landscape that we used in the introduction vignette and in the main text of the package manuscript as case study 1. This example is important, because the user will define each required object him/herself.

The first step is to load the gen3sis package:

```{r setup, message=F}
library(gen3sis)
```

## Creating the environmental data frames
In this step, the user needs to create the data frames containing the spatiotemporal distribution of the environmental variables of interest. Here, we will use the temperature, precipitation and area rasters of the 4d sample world that has been used in the introduction vignette. We first create a dataframe for each of the environmental variables. This dataframe contains the x- and y- coordinates of our world and each column represents one of the 300 time steps.

```{r eval=TRUE, message=F}
library(raster)
temperature_brick <- brick('inst/extdata/InputRasters/WorldCenter/temp_rasters.tif') #WIP
dynamic_landscape_temperature_dataframe <- as.data.frame(temperature_brick, xy=T)

precipitation_brick <- brick('inst/extdata/InputRasters/WorldCenter/prec_rasters.tif') #WIP
dynamic_landscape_precipitation_dataframe <- as.data.frame(precipitation_brick, xy=T)

area_brick <- brick('inst/extdata/InputRasters/WorldCenter/area_rasters.tif') #WIP
dynamic_landscape_area_dataframe <- as.data.frame(area_brick, xy=T)

```


If you want to learn how you can create a virtual dynamic landscape from scratch, please refer to the LINK vignette. 


## Creating a list with the environmental data frames
It is important to add the name of the environmental variable you want to use in the list, which will be used when specifying the config file. Here we name "temp" the data frame for temperature and "prec" for the data frame for precipitation
```{r eval=TRUE}
landscapes_list <- list("temp" = dynamic_landscape_temperature_dataframe, "prec" = dynamic_landscape_precipitation_dataframe, "area" = dynamic_landscape_area_dataframe) 
```
## Defining a cost function 
The second argument we need to define is a cost function. This function should define how connected and reachabel grid cells are via dispersal. For example, suitable terrestrial cells should pose no cost for dispersal, but dispersal over water grid cells should increase the cost of dispersal. The costs have to bedefined in meters because the coordinate system is in meters for real landscapes (automatically corrected to km in later on by the create_input() function). However, in our example all grid cells are suitable and contiguous and the distance unit is automatically in grid cell as we do not provide a coordinate system. Hence, we can define a simple cost function in which the dispersal is not penalized: 

```{r eval=TRUE}
my_cost_function <- function(){
    return(1)
}
```

## Further useful arguments
Besides the landscape list, the cost function and the experiment folder, we can define further arguments: directions, timesteps and calculate_full_distance_matrices. 
The argument 'directions' requires an interger providing the amound of directions used to calculate distances. It can take 4, 8, 16 as values to consider the four, eigth or 16 neiboring grid cells. This is the same homonimous argument used by the function transition in the gdistance package (gdistance::transition). 
The argument 'timesteps' requires a vector of strings of mode character and is used to name the files and to name the timesteps in the .rds landscape object created by the create_input() function. It is not necessary to define this argument, but it helps readibility when manipulating the object. 
The argument 'calculate_full_distance_matrices' defines whether the create_input() function will create one large distance matrix for all suitable grid cells (calculate_full_distance_matrices=TRUE) or a list of small distance matrices for the neigboring cells specified in 'directions' around each suitable grid cell (calculate_full_distance_matrices=FALSE). The full distance matrix confers faster computing speed for the model, but requires a larger storage. The local distance matrices cause a slower computing speed, but require smaller storage. The slower speed emerges form the fact that a full distance matrix is then reconstructed by concatenating local distances matrices each timestep during a simulation run. 

The real geographic coordinate system can be provided which allows for the global spherical distance correction. For real landscapes, the distance unit is in kilometers (km). In the case of hypothetical landscapes, as in our example, geographic distance is measured in units of grid cells.

## Create input files 

The model uses serialized R files (.rds) format for all inputs. The functions for processing the input data in the required format are available in the package. Once the data is processed, the simulation can be started with the function run_simulation().

```{r eval=FALSE}
create_input(landscapes = landscapes_list,
             cost_function = my_cost_function,
             output_directory = "../My_experiment_Input",# a directory name to save the files in
             directions = 8, # all surrounding grid cells from a focus cell
             timesteps = as.character(stringtimestepsnames), # just to name the files
             calculate_full_distance_matrices = TRUE  # full distance matrix
)
```
